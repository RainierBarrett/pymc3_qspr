import pymc3 as pm
import theano.tensor as tt
import matplotlib.pyplot as plt
import numpy as np

#<CONSTANTS>

DATA_DIR = 'data/'
MAX_LENGTH = 150
ALPHABET = 20

CLASS_NUMBER = 6
DATA_NUMBER = 1783
MOTIF_LENGTH = 3
MAX_MOTIF_LENGTH = 2

ALPHABET = ['A','R','N','D','C','Q','E','G','H','I',
            'L','K','M','F','P','S','T','W','Y','V']

#</CONSTANTS>

def read_data(datafile):
    '''Takes a properly-formatted peptide datafile and reads it into a numpy array.'''
    raw_data = np.genfromtxt(datafile)
    data = np.zeros((int(raw_data[-1][0]+1), MAX_LENGTH)) + 20 #20 indicates 'END'
    with open(datafile) as f:
        for i in range(len(f.readlines())):
            data[int(raw_data[i][0])][int(raw_data[i][1])] = raw_data[i][2]
    return(data)


def make_pep_file(sampled_peptides, alphabet=ALPHABET,
                  max_length=MAX_LENGTH, filename='pymc3_motif_peps.txt'):
    '''This will generate a peptide txt file containing the AA sequences of peptides generated by
        sampling from our fitted model.
        Params:
            @sampled_peptides: the ppc produced by sampling from the fitted model. 
            Dimensions should be N x MAX_LENGTH.
            @alphabet: the alphabet to use for 'translation' can be specified. Has default order.
            @max_length: the maximum length of a peptide possible. Defaults to 150.
            @filename: the name of the output file.
            '''
    assert(type(filename) is str)
    assert(len(alphabet) is 20)#need all the AA's for now
    sampled_seqs = [[] for i in range(len(sampled_peptides))]
    for i in range(len(sampled_peps)):
        for j in range(MAX_LENGTH):
            sampled_seqs[i].append(alphabet[sampled_peptides[i][j]-1])
            if sampled_peptides[i][j] == 20:
                break#stop if we see the "END" marker
    tot = 0
    for seq in sampled_seqs:
        tot += len(seq)
    print('Average sampled peptide length: {}'.format(tot/len(sampled_seqs)))
    sequence_strings = [''.join(item) for item in sampled_seqs]
    with open(filename, 'w+') as f:
        for seq in sequence_strings:
            f.write('{}\n'.format(seq))

apd_data =read_data(DATA_DIR+'APD.data')

model = pm.Model()
#specify priors
with model:
    #ignore motif classes for now until I understand how to deal with them...
    #motifClass = pm.DiscreteUniform('motifClass', 0, CLASS_NUMBER)
    #probs of going to each peptide (including 'END') at each 'spot' in the sequence
    #the +1 is for room for the "END" symbol
    p = pm.Dirichlet('p', a=np.ones((MAX_LENGTH, len(ALPHABET)+1)),
                     shape=(MAX_LENGTH, len(ALPHABET)+1))
    #the categories are the peptides, and one category is the END symbol, which will be represented by 20
    # that way we can stochastically terminate... there may be a better way to deal with length
    peptides = pm.Categorical('peptides', 
                              p=p,
                              shape=( MAX_LENGTH),
                              observed = apd_data)#now to process the data properly

print("Now beginning training...")
with model:
    trace = pm.sample(1000)
print("Sampling complete.")
print("Sampling from trained model...")
with model:
    ppc = pm.sample_ppc(trace, 2000)

sampled_peps = ppc['peptides']


            
make_pep_file(sampled_peps, filename='test_pymc3_motifs.txt')

